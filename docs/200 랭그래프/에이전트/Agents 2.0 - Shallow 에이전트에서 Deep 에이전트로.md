---
title: "Agents 2.0: 얕은 반복 루프에서 깊이 있는 에이전트로"
author: Philipp Schmid
date: 2025-10-12
source: https://www.philschmid.de/agents-2.0-deep-agents
tags:
  - AI에이전트
  - LangGraph
  - 딥에이전트
  - 에이전트아키텍처
  - 서브에이전트
  - 메모리
  - 계층적위임
related:
  - "[[워크플로우와 에이전트 패턴]]"
  - "[[에이전트 아키텍처 개념]]"
  - "[[Ambient Agents 소개]]"
---

# Agents 2.0: 얕은 반복 루프에서 깊이 있는 에이전트로

> 작성일: 2025년 10월 12일 | 읽는 시간: 5분

지난 1년 동안 AI 에이전트를 구축한다는 것은 대개 한 가지를 의미했습니다. while 반복 루프를 설정하고, 사용자 프롬프트를 받아 LLM에 전송하고, 도구 호출을 파싱하고, 도구를 실행하고, 결과를 다시 전송하고, 이를 반복하는 것입니다. 이것이 바로 우리가 **얕은 에이전트(Shallow Agent)** 또는 **에이전트 1.0**이라고 부르는 것입니다.

이 아키텍처는 "도쿄의 날씨는 어떤가요? 그리고 무엇을 입어야 할까요?"와 같은 트랜잭션 작업에는 매우 간단하고 효과적입니다. 하지만 3일 동안 50단계가 필요한 작업을 수행하도록 요청하면, 이러한 에이전트는 필연적으로 집중력을 잃거나, 컨텍스트를 놓치거나, 무한 루프에 빠지거나, 단일 컨텍스트 윈도우에 너무 많은 단계가 필요하여 환각을 일으킵니다.

우리는 지금 [Deep Agents](https://blog.langchain.com/deep-agents/) 또는 **에이전트 2.0**을 향한 아키텍처적 전환을 목격하고 있습니다. 이러한 시스템은 단순히 루프 안에서 반응하는 것이 아닙니다. 이들은 [에이전트 패턴](https://www.philschmid.de/agentic-pattern)을 결합하여 계획을 수립하고, [영속적인 메모리/상태](https://www.philschmid.de/memory-in-agents)를 관리하고, 특화된 [서브 에이전트](https://www.philschmid.de/the-rise-of-subagents)에게 작업을 위임하여 다단계의 복잡한 문제를 해결합니다.

## 에이전트 1.0: "얕은" 루프의 한계

우리가 어디로 가고 있는지 이해하려면, 먼저 우리가 어디에 있는지 이해해야 합니다. 오늘날 대부분의 에이전트는 "얕습니다". 이는 LLM의 컨텍스트 윈도우(대화 히스토리)에만 전적으로 의존하여 상태를 유지한다는 의미입니다.

1. **사용자 프롬프트:** "애플 주식 가격을 찾아서 좋은 매수 시점인지 알려주세요."
2. **LLM 추론:** "검색 도구를 사용해야겠습니다."
3. **도구 호출:** `search("AAPL stock price")`
4. **관찰:** 도구가 데이터를 반환합니다.
5. **LLM 응답:** 관찰 결과를 바탕으로 응답을 생성하거나 다른 도구를 호출합니다.
6. **반복:** 완료될 때까지 반복합니다.

이 아키텍처는 무상태(stateless)이고 일시적(ephemeral)입니다. 에이전트의 전체 "두뇌"는 컨텍스트 윈도우 안에 있습니다. 작업이 복잡해지면, 예를 들어 "10개의 경쟁사를 조사하고, 그들의 가격 모델을 분석하고, 비교 스프레드시트를 만들고, 전략적 요약을 작성하세요"와 같은 작업에서는 다음과 같은 이유로 실패합니다:

- **컨텍스트 오버플로우:** 히스토리가 도구 출력(HTML, 지저분한 데이터)으로 가득 차면서 지시사항이 컨텍스트 윈도우 밖으로 밀려납니다.
- **목표 상실:** 중간 단계의 노이즈 속에서 에이전트는 원래의 목표를 잊어버립니다.
- **복구 메커니즘 없음:** 엉뚱한 방향으로 빠지면, 멈추고, 되돌아가서, 새로운 접근 방식을 시도할 선견지명이 거의 없습니다.

얕은 에이전트는 5~15단계가 걸리는 작업에는 훌륭합니다. 하지만 500단계가 걸리는 작업에는 끔찍합니다.

## 에이전트 2.0의 아키텍처 (Deep Agents)

Deep Agents는 계획과 실행을 분리하고, 컨텍스트 윈도우 외부에서 메모리를 관리합니다. 이 아키텍처는 4가지 기둥으로 구성됩니다.

### 기둥 1: 명시적 계획 (Explicit Planning)

얕은 에이전트는 사고의 연쇄(chain-of-thought)를 통해 암묵적으로 계획합니다("나는 X를 해야 하고, 그 다음 Y를 해야 한다"). Deep Agents는 도구를 사용하여 명시적인 계획을 생성하고 유지하며, 이는 마크다운 문서의 To-Do 리스트일 수 있습니다.

매 단계마다 에이전트는 이 계획을 검토하고 업데이트하여 단계를 pending, in_progress, 또는 completed로 표시하거나 메모를 추가합니다. 단계가 실패하면, 맹목적으로 재시도하지 않고 실패를 수용하도록 계획을 업데이트합니다. 이를 통해 에이전트는 고수준 작업에 집중할 수 있습니다.

### 기둥 2: 계층적 위임 (Hierarchical Delegation) - 서브 에이전트

복잡한 작업에는 전문화가 필요합니다. 얕은 에이전트는 하나의 프롬프트에서 만능이 되려고 합니다. Deep Agents는 **오케스트레이터(Orchestrator) → 서브 에이전트(Sub-Agent)** 패턴을 활용합니다.

오케스트레이터는 작업을 [서브 에이전트](https://www.philschmid.de/the-rise-of-subagents)에게 위임하며, 각 서브 에이전트는 깨끗한 컨텍스트를 가집니다. 서브 에이전트(예: "연구자", "코더", "작가")는 도구 호출 루프(검색, 오류 발생, 재시도)를 수행하고, 최종 답변을 컴파일하고, 오케스트레이터에게 *종합된 답변만* 반환합니다.

> 관련 문서: [[워크플로우와 에이전트 패턴#서브 에이전트 패턴]]

### 기둥 3: 영속적 메모리 (Persistent Memory)

컨텍스트 윈도우 오버플로우를 방지하기 위해, Deep Agents는 파일 시스템이나 벡터 데이터베이스와 같은 외부 메모리 소스를 진실의 원천(source of truth)으로 활용합니다. Claude Code와 Manus 같은 프레임워크는 에이전트에게 `read`/`write` 접근 권한을 제공합니다. 에이전트는 중간 결과(코드, 초안 텍스트, 원시 데이터)를 작성합니다. 후속 에이전트는 파일 경로나 쿼리를 참조하여 필요한 것만 검색합니다. 이는 패러다임을 "모든 것을 기억하기"에서 "정보를 찾을 위치를 아는 것"으로 전환합니다.

> 참고: [[Ambient Agents 소개#메모리 관리]]

### 기둥 4: 극단적 컨텍스트 엔지니어링 (Extreme Context Engineering)

더 똑똑한 모델이 더 적은 프롬프팅을 필요로 하는 것은 아닙니다. 오히려 더 나은 컨텍스트를 필요로 합니다. "당신은 도움이 되는 AI입니다"라고 말하는 프롬프트로는 에이전트 2.0 행동을 얻을 수 없습니다. Deep Agents는 때로는 수천 개의 토큰에 달하는 매우 상세한 지시사항에 의존합니다. 이러한 지시사항은 다음을 정의합니다:

- 행동하기 전에 멈추고 계획을 세워야 하는 시기 식별
- 서브 에이전트를 생성할 때와 스스로 작업을 수행할 때의 프로토콜
- 도구 정의 및 사용 방법과 시기에 대한 예제
- 파일 이름 지정 및 디렉토리 구조에 대한 표준
- 휴먼-인-더-루프 협업을 위한 엄격한 형식

> 관련 문서: [[에이전트 아키텍처 개념#컨텍스트 엔지니어링]]

## Deep Agent 플로우 시각화

이러한 기둥들이 어떻게 결합되는지 살펴보겠습니다. 다음은 복잡한 요청을 처리하는 Deep Agent의 시퀀스 다이어그램입니다: *"양자 컴퓨팅을 연구하고 파일에 요약을 작성하세요."*

```
사용자 → 오케스트레이터: "양자 컴퓨팅을 연구하고 파일에 요약을 작성하세요"
오케스트레이터 → 계획 도구: 작업 계획 생성
계획 도구 → 오케스트레이터: plan.md 생성
  [ ] 양자 컴퓨팅 연구
  [ ] 요약 작성
  [ ] 파일에 저장

오케스트레이터 → 연구 서브에이전트: "양자 컴퓨팅 연구"
연구 서브에이전트 → 검색 도구: 여러 검색 수행
검색 도구 → 연구 서브에이전트: 결과 반환
연구 서브에이전트 → 오케스트레이터: research_findings.md 반환

오케스트레이터 → 계획 도구: 계획 업데이트
  [x] 양자 컴퓨팅 연구
  [진행중] 요약 작성

오케스트레이터 → 작가 서브에이전트: "research_findings.md를 기반으로 요약 작성"
작가 서브에이전트 → 파일 시스템: summary.md 작성
작가 서브에이전트 → 오케스트레이터: 완료 보고

오케스트레이터 → 계획 도구: 계획 업데이트
  [x] 양자 컴퓨팅 연구
  [x] 요약 작성
  [x] 파일에 저장

오케스트레이터 → 사용자: "summary.md에 요약이 작성되었습니다"
```

## 결론

얕은 에이전트에서 Deep Agents로 이동하는 것(에이전트 1.0에서 에이전트 2.0으로)은 단순히 LLM을 더 많은 도구에 연결하는 것이 아닙니다. 이는 반응적인 루프에서 능동적인 아키텍처로의 전환입니다. 모델을 중심으로 한 더 나은 엔지니어링에 관한 것입니다.

명시적 계획, [서브 에이전트](https://www.philschmid.de/the-rise-of-subagents)를 통한 계층적 위임, 그리고 [영속적 메모리](https://www.philschmid.de/memory-in-agents)를 구현함으로써, 우리는 컨텍스트를 제어할 수 있습니다. 그리고 컨텍스트를 제어함으로써, 우리는 복잡성을 제어하고, 단 몇 초가 아닌 몇 시간 또는 며칠이 걸리는 문제를 해결할 수 있는 능력을 잠금 해제합니다.

## 감사의 말

이 개요는 깊이 있고 수동적인 연구의 도움으로 작성되었습니다. [**"Deep Agents"**](https://blog.langchain.com/deep-agents/)라는 용어는 특히 LangChain 팀에 의해 이 아키텍처적 진화를 설명하기 위해 대중화되었습니다.

---

읽어주셔서 감사합니다! 질문이나 피드백이 있으시면 [Twitter](https://twitter.com/_philschmid) 또는 [LinkedIn](https://www.linkedin.com/in/philipp-schmid-a6a2bb196/)에서 알려주세요.

## 관련 문서

- [[워크플로우와 에이전트 패턴]]
- [[에이전트 아키텍처 개념]]
- [[Ambient Agents 소개]]
- [[LLM 에이전트 아키텍처 패턴]]
