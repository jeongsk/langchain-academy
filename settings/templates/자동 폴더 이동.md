<%*
// aiProvider ì„¤ì •
// Note: AI Providers í”ŒëŸ¬ê·¸ì¸ì—ì„œ providerë¥¼ ë¯¸ë¦¬ ì„¤ì •í•´ì•¼ í•©ë‹ˆë‹¤
// AI Providers: <https://obsidian.md/plugins?id=ai-providers>
const PROVIDER_NAME = "ollama:gpt-oss"; // AI Providers í”ŒëŸ¬ê·¸ì¸ì—ì„œ ì„¤ì •í•œ provider ì´ë¦„

// í˜„ìž¬ íŒŒì¼ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
const currentFile = tp.file.find_tfile(tp.file.title);
if (!currentFile) {
    new Notice("í˜„ìž¬ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
    return;
}

// ë³¼íŠ¸ì˜ í´ë” êµ¬ì¡° ê°€ì ¸ì˜¤ê¸° (TFolder í´ëž˜ìŠ¤ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ)
const allFiles = app.vault.getAllLoadedFiles();
const allFolders = allFiles
    .filter(f => f.children !== undefined) // í´ë”ëŠ” children ì†ì„±ì„ ê°€ì§
    .map(f => f.path)
    .filter(path => path !== "" && path !== "/")
    .sort();

// í´ë” êµ¬ì¡°ë¥¼ ë¬¸ìžì—´ë¡œ ë³€í™˜
const folderStructure = allFolders.join("\n");

// ë…¸íŠ¸ ë‚´ìš© ê°€ì ¸ì˜¤ê¸°
const fileContent = tp.file.content;
const fileName = tp.file.title;

// í´ë” ì¶”ì²œ í”„ë¡¬í”„íŠ¸
const systemPrompt = `ë‹¹ì‹ ì€ **Obsidian ë…¸íŠ¸ ê´€ë¦¬ ì „ë¬¸ê°€**ë¡œì„œ, ë…¸íŠ¸ì˜ ë‚´ìš©ê³¼ ì œëª©ì„ ë¶„ì„í•˜ì—¬ ê°€ìž¥ ì ì ˆí•œ í´ë”ë¥¼ ì¶”ì²œí•˜ëŠ” ì—­í• ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.

ë‹¤ìŒ ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ë¶„ì„í•´ì£¼ì„¸ìš”:

1. **íŒŒì¼ëª…**: ${fileName}
2. **ì‚¬ìš© ê°€ëŠ¥í•œ í´ë” ëª©ë¡**:
${folderStructure}

3. **íŒŒì¼ ë‚´ìš©**: (ì•„ëž˜ ì œê³µ)

ë¶„ì„ ê¸°ì¤€:

- ë…¸íŠ¸ì˜ ì£¼ì œì™€ ë‚´ìš© ìœ í˜•
- íŒŒì¼ëª…ì˜ íŒ¨í„´ì´ë‚˜ í‚¤ì›Œë“œ
- ë¬¸ì„œì˜ ëª©ì  (ì¼ê¸°, íšŒì˜ë¡, í”„ë¡œì íŠ¸, ì•„ì´ë””ì–´, ì°¸ê³ ìžë£Œ ë“±)
- ê¸°ì¡´ í´ë” êµ¬ì¡°ì™€ì˜ ì¼ê´€ì„±

ì‘ë‹µ í˜•ì‹:
ë°˜ë“œì‹œ ë‹¤ìŒ JSON í˜•íƒœë¡œë§Œ ì‘ë‹µí•´ì£¼ì„¸ìš”:
{
  "recommended_folder": "ì¶”ì²œí•˜ëŠ” ì •í™•í•œ í´ë” ê²½ë¡œ",
  "confidence": "ë†’ìŒ/ë³´í†µ/ë‚®ìŒ",
  "reason": "ì¶”ì²œ ì´ìœ ë¥¼ í•œ ë¬¸ìž¥ìœ¼ë¡œ ì„¤ëª…",
  "alternative_folders": ["ëŒ€ì•ˆ í´ë”1", "ëŒ€ì•ˆ í´ë”2"]
}

ì¤‘ìš”: ì¶”ì²œí•˜ëŠ” í´ë”ëŠ” ë°˜ë“œì‹œ ìœ„ì˜ ì‚¬ìš© ê°€ëŠ¥í•œ í´ë” ëª©ë¡ì— ìžˆëŠ” ê²ƒì´ì–´ì•¼ í•©ë‹ˆë‹¤. ì¡´ìž¬í•˜ì§€ ì•ŠëŠ” í´ë”ë¥¼ ì¶”ì²œí•˜ì§€ ë§ˆì„¸ìš”.`;

try {
    // AIì—ê²Œ í´ë” ì¶”ì²œ ìš”ì²­ (aiProvider ì‚¬ìš©)
    const provider = app.aiProviders.providers.find(e => e.name === PROVIDER_NAME);
    const messages = [
  { role: "system", content: systemPrompt },
  { role: "user", content: `íŒŒì¼ ë‚´ìš©:\n${fileContent}` }
 ];
    const aiResponse = await app.aiProviders.execute({ provider, messages, onProgress: (_chunk, text) => text });

    // JSON íŒŒì‹±
    let recommendation;
    try {
        // AI ì‘ë‹µì—ì„œ JSON ë¶€ë¶„ë§Œ ì¶”ì¶œ (ë§ˆí¬ë‹¤ìš´ ì½”ë“œ ë¸”ë¡ ì œê±°)
        const cleanResponse = aiResponse.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
        const jsonMatch = cleanResponse.match(/\{[\s\S]*\}/);
        const jsonString = jsonMatch ? jsonMatch[0] : cleanResponse;
        recommendation = JSON.parse(jsonString);
    } catch (parseError) {
        new Notice("AI ì‘ë‹µì„ íŒŒì‹±í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
        console.error('Parse Error:', parseError);
        return;
    } finally {
        console.log('AI Response:', aiResponse);
    }

    // ì¶”ì²œ ê²°ê³¼ í‘œì‹œ ë° ì‚¬ìš©ìž ì„ íƒ
    const options = [
        `âœ… ì¶”ì²œ: ${recommendation.recommended_folder} (${recommendation.confidence})`,
        ...recommendation.alternative_folders.map(folder => `ðŸ“ ëŒ€ì•ˆ: ${folder}`),
        "ðŸ” ë‹¤ë¥¸ í´ë” ì„ íƒ",
        "âŒ ì·¨ì†Œ"
    ];

    const values = [
        recommendation.recommended_folder,
        ...recommendation.alternative_folders,
        "manual_select",
        "cancel"
    ];

    const selectedOption = await tp.system.suggester(
        options,
        values,
        false,
        `í´ë” ì¶”ì²œ ê²°ê³¼:\n${recommendation.reason}\n\nì´ë™í•  í´ë”ë¥¼ ì„ íƒí•˜ì„¸ìš”:`
    );

    let targetFolder = null;

    if (selectedOption === "manual_select") {
        // ìˆ˜ë™ í´ë” ì„ íƒ
        targetFolder = await tp.system.suggester(
            allFolders.map(f => f || "Root"),
            allFolders,
            false,
            "ìˆ˜ë™ìœ¼ë¡œ í´ë”ë¥¼ ì„ íƒí•˜ì„¸ìš”:"
        );
    } else if (selectedOption !== "cancel" && selectedOption !== undefined) {
        targetFolder = selectedOption;
    }

    // íŒŒì¼ ì´ë™ ì‹¤í–‰
    if (targetFolder) {
        // ëŒ€ìƒ í´ë” ì¡´ìž¬ í™•ì¸
        const folderExists = app.vault.getAbstractFileByPath(targetFolder);
        if (!folderExists) {
            new Notice(`í´ë” "${targetFolder}"ê°€ ì¡´ìž¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.`);
            return;
        }

        try {
            const newPath = `${targetFolder}/${currentFile.name}`;
            await app.fileManager.renameFile(currentFile, newPath);
            
            new Notice(`âœ… ë…¸íŠ¸ê°€ "${targetFolder}" í´ë”ë¡œ ì´ë™ë˜ì—ˆìŠµë‹ˆë‹¤!\nì´ìœ : ${recommendation.reason}`);
            
            // ì´ë™ ë¡œê·¸ë¥¼ ì½˜ì†”ì— ê¸°ë¡
            console.log(`File moved: ${currentFile.path} â†’ ${newPath}`);
            console.log(`Recommendation confidence: ${recommendation.confidence}`);
            
        } catch (error) {
            new Notice(`âŒ ì´ë™ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message}`);
            console.error('Move Error:', error);
        }
    } else {
        new Notice("ì´ë™ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.");
    }

} catch (error) {
    new Notice(`âŒ AI ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message}`);
    console.error('AI Analysis Error:', error);

    // ì˜¤ë¥˜ ë°œìƒ ì‹œ ìˆ˜ë™ í´ë” ì„ íƒìœ¼ë¡œ í´ë°±
    const fallbackFolder = await tp.system.suggester(
        ["AI ë¶„ì„ ì‹¤íŒ¨ - ìˆ˜ë™ìœ¼ë¡œ í´ë”ë¥¼ ì„ íƒí•˜ì„¸ìš”:", ...allFolders],
        [null, ...allFolders],
        false,
        "ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ìˆ˜ë™ìœ¼ë¡œ í´ë”ë¥¼ ì„ íƒí•˜ì‹œê² ìŠµë‹ˆê¹Œ?"
    );
    
    if (fallbackFolder) {
        try {
            const newPath = `${fallbackFolder}/${currentFile.name}`;
            await app.fileManager.renameFile(currentFile, newPath);
            new Notice(`ë…¸íŠ¸ê°€ "${fallbackFolder}" í´ë”ë¡œ ì´ë™ë˜ì—ˆìŠµë‹ˆë‹¤. (ìˆ˜ë™ ì„ íƒ)`);
        } catch (moveError) {
            new Notice(`ì´ë™ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${moveError.message}`);
        }
    }
}
%>
